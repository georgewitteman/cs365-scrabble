# Scrabble (CS365 Final Project)

*Emily Stamm & George Witteman*

## How to Use

First compile and load the file `basic-defns.lisp`. Then you can compile and load all the other files by typing `(cl)`. Then you are ready to play the game

The organization of the files is as follow. The file `basic-defns.lisp` has basic functions and data structures for basic set up of Scrabble, such as the `SCRABBLE` and `TILE` data structures and the corresponding print functions, as well as most of the constants. The file `play-scrabble.lisp` has the rest of the functions used in the implementation of scrabble (primarily destructive functions), including `do-move!`, `trade-in!`, `pass!`, and their helper functions. The file `trie.lisp` defines the `TRIE` and `TR-NODE` data structures that form the word trie’s as used in the Appel and Jacobson algorithm. Note that they modified this algorithm to use Directed Acyclic Word Graphs (DAWG) to save space, but as space was not a problem we kept them as word tries. The `move-generation.lisp` file contains the functions required to generate moves, also as outlined in the Appel and Jacobson algorithm. There is also a `find-best-move` function, which finds the move that gives a player the highest score out of the list of possible words generated by `generate-moves`. The `begin` file outlines some convenient print functions. The `ospd.txt` file is the scrabble dictionary we use for this implementation, which is read using the file `file-read.lisp`.

To play the game, start by typing `(setf g (new-scrabble))` in the command line. This will start the Scrabble game, which will appear on the screen, in addition to some preliminary instructions. At any time, you can type `(rules)` to see the rules or `(commands)` to see the list of possible commands. To make a word, type `(do-move! g t string ‘((row[1] col[1]) ... (row[n] col[n])))` where the string is the word you want to put on the board (including the anchor letter which is already on the board) and each `(row[i] col[i])` is the row and column corresponding to the ith character in the string. For example, if you wanted to place the word "dog" as the first word on the board, you would type: 

    (do-move! g t ‘((7 7) (7 8) (7 9))

You can also use the functions `find-best-move` to find the move with the highest score, as well as `do-best-move!` and `do-random-move!` to do a best and random move, respectively. Finally, instead of doing a move, you can trade in any number of letters by using the `trade-in!` function or pass your turn using the `pass!` function. With the `trade-in!` function, you specify the indices of the tiles in your rack that you want to trade in as a list. For instance, if you wanted to trade in the first and third tile in your rack, you would type:

    (trade-in! g ‘(0 2))
    
Lastly, you can also have the computer play games entirely on it's own. `(play-random-game)` will play a random game, and `(random-vs-best)` will play a game where player 1 does random moves and player 2 does the best moves.

## The Algorithm for Move Generation

To generate all legal scrabble moves we implemented Appel and Jacobson algorithm for move generation as described in the paper below. The general outline of the algorithm is as follows:

  1. Compute cross-check sets. A cross-check set for a given space is the legal tiles that can be placed in that space. For example, the cross-check sets for all spaces on an empty board are all letters, and the set for a tile to the right of an 'a' would contain all letters - such that there exists a word with "a-" in that word.
  2. Compute anchor squares. Anchor squares are all squares that are adjacent to a tile already placed on the board.
  3. For each anchor square find all possible left-parts. A left part can either be empty, tiles already on the board, or the start of a word in the dictionary.
  4. For each left-part, generate all possible right parts of a word.
  5. Append left-part and right-part, and if they create a word then add it to the list of legal moves.
  
## Trie Data Structure

This algorithm makes heavy use of the *trie* structure to efficiently generate left and right-parts of words. A trie is simply a tree whose edges are labeled by letters. If the nodes from the root node to a given node create a valid word, `is-word` gets marked as `t`. A more detailed description of the *trie* is given in the Appel and Jacobson paper.

Andrew W. Appel and Guy J. Jacobson
 “The World’s Fastest Scrabble Program”
https://pdfs.semanticscholar.org/da31/cb24574f7c881a5dbf008e52aac7048c9d9c.pdf
